use core::fmt;
use std::collections::BTreeSet;
use std::hash::Hash;

use super::block::MBlock;
use super::context::MContext;
use super::operand::PReg;
use crate::infra::linked_list::LinkedListContainer;
use crate::infra::storage::{Arena, ArenaPtr, GenericPtr};

// Label used in machine code.
#[derive(Debug, Clone)]
pub struct MLabel(String);

impl fmt::Display for MLabel {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl PartialEq for MLabel {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}

impl Eq for MLabel {}

impl Hash for MLabel {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.0.hash(state)
    }
}

impl<T> From<T> for MLabel
where
    T: AsRef<str>,
{
    fn from(value: T) -> Self {
        Self(value.as_ref().to_string())
    }
}

/// Data of machine function.
pub struct MFuncData {
    self_ptr: MFunc,
    /// The label of the function
    label: MLabel,
    /// The stack size of local slots/variables.
    /// 
    /// All memory positions generated by `alloca` instruction will result into
    /// a slot on the stack of the function frame.
    storage_stack_size: u64,
    /// The stack size for argument passing in call instructions within the
    /// function.
    /// 
    /// This field is optional. The stack for argument passing can be created
    /// lazily, or in the function prologue. Only when it is handled in the
    /// prologue is this field useful.
    outgoing_stack_size: u64,
    /// The saved registers
    ///
    /// [`BTreeSet`] is used here to make sure the order of physical registers 
    /// are kept the same.
    saved_regs: BTreeSet<PReg>,
    /// If this function is an external function, i.e. only the declaration
    /// appeared in the IR.
    is_external: bool,
    // linked-list stuff.
    head: Option<MBlock>,
    tail: Option<MBlock>,
}

impl MFuncData {
    /// Get the corresponding MFunc pointer.
    pub fn self_ptr(&self) -> MFunc {
        self.self_ptr
    }
}

#[derive(Debug, PartialEq, Eq)]
pub struct MFunc(GenericPtr<MFuncData>);

impl Clone for MFunc {
    fn clone(&self) -> Self {
        *self
    }
}

impl Copy for MFunc {}

impl Hash for MFunc {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.0.hash(state)
    }
}

impl MFunc {
    /// Get the label of the function.
    pub fn label(self, arena: &MContext) -> &MLabel {
        &self.deref(arena).label
    }

    /// Create a new machine function.
    pub fn new(mctx: &mut MContext, label: impl Into<MLabel>) -> Self {
        mctx.alloc_with(|self_ptr| MFuncData {
            self_ptr,
            label: label.into(),
            storage_stack_size: 0,
            outgoing_stack_size: 0,
            saved_regs: BTreeSet::default(),
            is_external: false,
            head: None,
            tail: None,
        })
    }

    /// Check if the function is an external function (library function).
    pub fn is_external(self, mctx: &MContext) -> bool {
        self.deref(mctx).is_external
    }

    /// Add the function's storage stack size by `size`.
    pub fn add_storage_stack_size(self, mctx: &mut MContext, size: u64) {
        self.deref_mut(mctx).storage_stack_size += size;
    }

    /// Get the function's storage stack size.
    pub fn storage_stack_size(self, mctx: &MContext) -> u64 {
        self.deref(mctx).storage_stack_size
    }
    
    /// Update the function's outgoing stack size to `size` if `size` is larger.
    pub fn update_outgoing_stack_size(self, mctx: &mut MContext, size: u64) {
        if size > self.outgoing_stack_size(mctx) {
            self.deref_mut(mctx).outgoing_stack_size = size;
        }
    }

    /// Get the function's outgoing stack size.
    pub fn outgoing_stack_size(self, mctx: &MContext) -> u64 {
        self.deref(mctx).outgoing_stack_size
    }

    /// Get the function's outgoing stack size and set it to zero.
    pub fn take_outgoing_stack_size(self, mctx: &mut MContext) -> u64 {
        let size = self.outgoing_stack_size(mctx);
        self.deref_mut(mctx).outgoing_stack_size = 0;
        size
    }

    /// Get the function's saved registers.
    pub fn saved_regs(self, mctx: &MContext) -> Vec<PReg> {
        let mut regs: Vec<PReg> = self.deref(mctx).saved_regs.iter().copied().collect();
        // we need to sort the registers to make the order of saved registers
        // deterministic
        regs.sort();
        regs
    }

    /// Add a saved register to the function.
    pub fn add_saved_reg(self, mctx: &mut MContext, reg: PReg) {
        self.deref_mut(mctx).saved_regs.insert(reg);
    }
}

impl ArenaPtr for MFunc {
    type Arena = MContext;
    type Data = MFuncData;
}

impl Arena<MFunc> for MContext {
    fn alloc_with<F>(&mut self, f: F) -> MFunc
    where
        F: FnOnce(MFunc) -> MFuncData,
    {
        MFunc(self.funcs.alloc_with(|p| f(MFunc(p))))
    }

    fn try_deref(&self, ptr: MFunc) -> Option<&MFuncData> {
        self.funcs.try_deref(ptr.0)
    }

    fn try_deref_mut(&mut self, ptr: MFunc) -> Option<&mut MFuncData> {
        self.funcs.try_deref_mut(ptr.0)
    }

    fn try_dealloc(&mut self, ptr: MFunc) -> Option<<MFunc as ArenaPtr>::Data> {
        self.funcs.try_dealloc(ptr.0)
    }
}

impl LinkedListContainer<MBlock> for MFunc {
    type Ctx = MContext;

    fn head(self, ctx: &Self::Ctx) -> Option<MBlock> {
        self.deref(ctx).head
    }

    fn tail(self, ctx: &Self::Ctx) -> Option<MBlock> {
        self.deref(ctx).tail
    }

    fn set_head(self, ctx: &mut Self::Ctx, head: Option<MBlock>) {
        self.deref_mut(ctx).head = head;
    }

    fn set_tail(self, ctx: &mut Self::Ctx, tail: Option<MBlock>) {
        self.deref_mut(ctx).tail = tail;
    }
}
